# 背景
主要是针对 [FRP && FP](讲讲FRP_FP.md) 说一下个人看法.

这篇文章里从内容上来看,有`范式` ,`编程范式`,`计算机模型分析`,`FRP`,` FP`,`命令式编程 && 函数式编程`,`JS中一些实例`,`闭包,纯函数,高阶函数`等等. 平心而论,虽然题目是`讲讲FRP_FP`,但内容里FRP讲的少. 
我半路出家,学艺不精,看完还是没明白啥是FRP.

在具体针对各个观点讨论前,我先得介绍一下我自己.要不然很容易引起误会.
我大学不是计算机专业,学地理的我.非科班出身,做计算机完全是兴趣加实用.
喜欢这东西,有趣,我就愿意多折腾. 毕业的时候,它顺带能给我找份工作,糊个口.别人花钱雇我去做我喜欢做的事情.
这是很开心的事.至于其他的,没过多做计较.南来北往的,去过正规的IT公司,也去过毫无IT味道可言的企业. 
总之,入这行的经历及初心,让我不太一样. 而且直到现在,我内心也不认同程序员或者码农这个称号. 我不认为我属于这个群体.
我觉得我写代码的时候,是在写作,或者对话,是有趣的事情. 
IT从业者都是人,是人的地方就是江湖. 有江湖就有门派. 科班与草根. 我毫无疑问,草根一族了. 草根大都自学成才的. 他们一般有他们自己的理念与方法. 我也一样. 我可以分享一下我的的理念及方法.简单主义(注意，是简单不是极简,没有这个极字),实用主义.简而言之,就是没有品味没有追求的能用就好. 
梅芬梅小姐不出意外应是科班出身. 比起正宗CS的博大精深,我的这些个人三脚猫,自然是难登大雅之堂,入不得厅门. 
但如果你想真正理解明白我说的内容,最好先空杯,忘掉头脑中CS的种种,就像倚天屠龙记里张三丰给张无忌教太极拳太极剑一样.
忘完所有,然后你看我说的对不对,对的你吸收,不对的你丢弃即可.

1. 编程范式
程序是现实世界的抽象. 所谓`编程范式`,说白了就是你怎么看待理解这个世界,然后以程序的语言表述出来.
如果在你的眼里,世界里所有的一切都是`函数`,所有的活动,都可以通过`函数调用`来完成,那你就是函数式了.
如果你理解世界的方式是基于`方以类聚,物以群分`,那面向对象这种很适合你.
如果你理解世界的方式是比较悲观的,`冥冥之中，自有天意`,人生每一步都是老天安排好的. 那指令式,面向过程这种就很适合你.
但是,世界是非常复杂的. 所有的范式难免盲人摸象的感觉.只得一角,不见全图. 窥一斑而知全豹这种情况在我看来是不存在的.
所以,我个人比较推崇混合范式编程. 像Scala,Julia这种语言,它不做限制. 至于你在写代码的时候,到底运用了哪套范式,我不在乎的.
我建议是根据具体场景,具体问题具体分析. 尺有所短寸有所长. 在合适的地方用适合的东西. 在都合适的地方用熟悉的东西.
当然,这会导致一个结果. 就是乍一看,你的代码乱七八糟.一会儿FP一会儿OO的.这个是代价,需要自己判断做取舍.

2. 计算模型分析
所谓计算模型,就是回答一个问题,计算机怎么做计算? 
回答这个问题前,得先说明白,什么是计算机. 计算机就是用来做计算的机器.
那又抛出一个问题，什么是计算? 也就是计算的本质到底是什么.
关于计算的本质,目前我个人了解到的有两个答案. 
一个是图灵的回答. 一个是邱奇的回答.
图灵的答案是这样的. 计算呢,就是计和算. 计,就是存储.(把东西记下来嘛) 算,就是运算.(算一下1+1等于几).
最简单的符合冯诺依曼体系的计算机,是"结绳记事". 给我一根绳子,我就成了计算机. 这里面有IO系统,(眼睛),有控制系统(手),有CPU和内存(绳). 怎么理解呢? 打一个结,就是存储一. 打两个结就是存储二. 它可以存储. 同理,我要做一次加法,我多打一个结. 我要做一次减法,我拆掉一个结. 所以,计就是算,算就是计.CPU里面全是寄存器. 所谓算法里的时间换空间或空间换时间.其实也是源于此.
那从图灵这种套路出发, 计算机怎么做计算这个问题，答案大概就是这样的了. 计算机通过存储+控制,(也可以说数据结构+算法),通过操作指令来更新数据实现计算.

邱奇的答案是这样的. 邱奇是逻辑学家. 逻辑学家没有计算的概念的,他们有自己的语言,他们不讲这一套.
逻辑学是刨根问底儿的学问. 逻辑的基石必须稳固. 不然最后的结论很可能就错了.
逻辑学有一些发展阶段,什么论证逻辑(比如命题啊,归纳演绎啊),到后面有形式逻辑,符号逻辑. 这方面我根本不懂.
但是有两点我比较清楚.
一, 布尔代数或者集合论这些数学工具可以跟逻辑学里面的那些规则及运算建立映射关系. 从而,研究数学就等于研究逻辑学,研究逻辑学也等同于研究数学.
二,lambda演算可以拿来计算
第一点不多说,说说第二点.
所有的逻辑都需要一个基石. lambda演算的基石就是lambda表达式. 
一个lambda表达式是一个只有一个参数的匿名函数.比如 (x)=>x
只有一个参数,那多不好玩. 所以就有了柯里化.
柯里化是这样的 ,
比如一个加法lambda (x,y)=> (y)=> x +y 
可以试一下JS中调用
```
// 1 + 2
((x,y)=> (y)=> x +y ) (1)(2) 
// 3
```
或者一个 select second lambda (first,second)=>  (second)=> second
```
// select_second ('hello',' world')
((first,second)=>  (second)=> second) ('hello')('world')
// "world"
```

总之, 柯里化其实是个语法糖,它可以使我们用单参函数,来表示多参函数. 
这种思想非常重要,多的是通过单的通过某种手法呈现出来的.

紧接着说说`高阶函数`
在lambda演示里,`高阶函数`是很自然的东西. 因为它的基石只有lambda表达式,也就是匿名函数.
一个返回函数的函数就是高阶函数. 比如柯里化后的多参函数就是高阶函数.
在上面的JS示例中,我们的参数有1,2,'hello','world'. 但目前,这些东西是没有的.我们的定义域内,只有一个东西,就是lambda表达式.

但是这些东西其实是可以定义出来的.
一个非常有趣的例子就是,邱奇数. 具体理论上的我不说,我也不会. 我简单说一下,主要是有三个东西.
一个起点(也就是零),一个前进函数(也叫前继),一个后退函数(也叫后继). 总之,相关理论可以参看,自然数公理化.
什么意思呢?
0是预定义的. 前进和后退也是预定义的. 要想得到1,0前进一步得到的结果就是1.
在lambda里面这样表示:

zero=(x)=>x
forward=(x)=>()=>x
backward=(x)=>x()
// 一般叫SUCC函数..
可以验证一下
```
var one=forward(zero)
var two=forward(one)

console.log(backward(two)===one)  // true
console.log(backward(one)===zero) //true
```
总之,大意如此.
自然数是可以通过lambda演算来定义的.
有了数之后,紧接着是加法. 为什么是加法? 因为减法是可以由加法定义的,乘法也是可以由加法定义的.
```
add(a, b){
    if(a===zero){
        retrun b
    }
    else{
        return add(backward(a),forward(b))
    }
}
```
什么意思呢? 加法是被定义的. 两条规则,1. 0和任何数的加法是对应的数. 2. 如果这个数非零,那就等于a的后退加b的前进.
 比如 2+3,2非零,就等于1+4. 1非零,就等于0+5. 0加任何数等于对应的数,那么就返回5.

 在这里我们要注意. 加法运算是通过公理化的定义实现的. 而不是之前"多打个结"这种存储的方式实现.
 这是我感觉邱奇的答案最美妙的地方.优雅的很.

 上面的例子中,引用到了几个没有定义的东西, 一个是递归调用add,另一个是 if else 逻辑判断. 
 下面说说 用lambda来定义布尔运算,也就是逻辑判断. 最后再构造if else.
 一般编程里 0,1表示true ,false. 这里我们也可以借鉴. 此次不借鉴,我举个其他书上的例子.
 T =(first)=>(second)=>first
 F =(first)=>(second)=>second
 IF =(x)=>x
这里我定义了true 和 false 和if
可以看一眼执行结果.符合预期.
```
IF(T)(1)(2) 
// 1
IF(F)(1)(2)
//2
```
顺带我定义一个逻辑操作符  AND 
这里可以根据真值表来构造AND函数, true and ture = true ,true and false = false ,false and true = false,false and false =false. 这里可以看到,只有第一种情况返回true,其他情况直接返回false.
那么我的 and 可以这样定义.
```
and=(p)=>(q)=>IF(p)(IF(q)(T)(F))(F)
// 验证一下
and(T)(T)==T //true
and(T)(F)==F //true
```
其他的not or 以此类推.

下面需要说说递归调用add这个怎么处理.
lambda表达式是匿名函数.我们这里所有的东西目前而言,没有说到怎么定义一个有名的表达式. 
比如刚刚提到的 zero=(x)=>x . 这里我们直接使用了=来定义,但并没有说怎么使用lambda来定义这个=.
这个后面再说. 目前说一下,匿名函数怎么递归. 递归就是自己调用自己.
有名的好理解. 比如阶乘函数
```
factorial=(n)=>{
     if(n===1){return 1}
     return  n*factorial(n-1)
}
   
```
这里面 求n的阶乘的时候,用到了n-1的阶乘.

在lambda里面有个函数叫y组合子,当然也有其他组合子. 数学上叫不动点.相关的有不动点定理.
这是个啥玩意?
举个例子, 你有一张上海市地图,拿了根针,从地图上随便扎过去.钉到地上. 
不动点定理是说,你肯定能找到一个点,地图上扎的点和钉到地上的点是同一个地方. 而你找到的这个点就是个不动点.
数学上呢,f(x)=x,满足这个关系的就是不动点.

Y组合子呢就是个不动点方程,这个方程里所有的点都是不动点. 就像一扇神奇的门,你推开门进去后发现,对面推门而入的那个人是你自己.

Y = λf.(λx.f (x x)) (λx.f (x x))
这是它的定义,关于它的推导过程,我也不会啊.但是,不影响直接拿来用.
```
// λf. (λx. f (λy. x x y)) (λx. f (λy. x x y))

const Y = f =>
(x => f(y => x(x)(y)))
(x => f(y => x(x)(y)))

// 调用
Y(myself=>n=>n==1?1:n*myself(n-1)) (5) 
// 120
```
总之,很神奇啦. 至于这个不动点是怎么传来传去,又调用到自己的.我是想不明白. 也不多想了.
但是有一点可以断定,不动点是联系两个空间的点.想象一下上海地图和上海.在那个不动点处,它同时在两个空间里有相同的表现.
这让我思考.或许我可以和另一个空间沟通,只要某种条件下我能成为两个空间的不动点. 这个条件,也就是这个函数,可以想象,肯定非常有趣. 
比如未来的我是一个空间,现在的我处于一个空间. 如果有个"针","穿透地图,落到地上,砸到我身上",我成为两个空间的不动点.
想象不来会有什么情况发生.
关于递归就这么多吧.
至于闭包,是为了消除lambda表达式中外部变量引用. 纯函数嘛,纯不纯看有没有副作用. 另外还有幂等性,引用透明性等概念也没讨论.
lambda演算部分就此别过.

下面说说函数式编程.
lambda表达式在一些语言里对应着一个匿名函数. 但是匿名函数又不是lambda表达式,因为lambda表达式是单参的.
这里不做深究,没意义,迷迷糊糊地用就行.
函数式编程,有很多概念和定义.这里我只说我的几点倾向.
1. 函数需是一等公民,鼓励纯函数
2. 数据流主导控制流
3. 使用不可变数据

这里必须得说说LISP, 这个我认为虽然它常常和函数式编程联系在一起,但它和函数式编程本质上不同.
因为LISP里面最根本的元素不是函数,而是list(列表). 它这个列表的特殊之处是,如果它的列表头,就是第一项是一个符合,它会找这个符合的定义,去把它当函数来执行,参数是列表的剩余项.
这也是LISP为什么称自己"代码既数据,数据既代码".
它可以理解为纯数据流.
它们的关系是 list是最根本的,基于list的特例(也就是第一个元素是符号), 把这个列表转换为一个函数,
在LISP里,函数其实是二级公民. 虽然一级公民的list很庞大,但是纯静态的列表,
计算的能力太弱了(感觉可能没有,但是我也不能确定,一堆静态的列表数据能不能计算).所以,二级公民俨然一级公民了.

呃,还没谈到FRP...但我已经饿晕了快.后面再补充吧..











